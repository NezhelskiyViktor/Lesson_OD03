#  Алгоритмы сортировки

Результаты урока:

- Поняли основные принципы работы алгоритмов сортировки.
- Познакомились с различными видами алгоритмов сортировки.

## ЗАДАНИЕ
Реализуйте один или несколько видов алгоритмов сортировки.

## Решение
1. [Пузырьковая сортировка (Bubble Sort)](bubble_sort.py):
```bubble_sort.py
# Определение функции bubble_sort, которая принимает список
def bubble_sort(a):
    # Задание переменной n равной количеству элементов в списке
    n = len(a)

    # Цикл, который будет выполняться n-1 раз
    for j in range(n - 1):
        # Вложенный цикл, который проходит по неотсортированной части списка
        for i in range(n - 1 - j):
            # Проверка, если текущий элемент больше следующего
            if a[i] > a[i + 1]:
                # Выполняем обмен значениями элементов, если порядок нарушен
                a[i], a[i + 1] = a[i + 1], a[i]
    # Возврат отсортированного списка a
    return a


# Вызов функции с заданным списком и вывод результата
print(bubble_sort([5, 7, 4, 3, 8, 2]))  
# Результат = [2, 3, 4, 5, 7, 8]
```
2. [Сортировка выбором (Selection Sort)](selection_sort.py):
```selection_sort.py
# Определение функции selection_sort, принимающей список arr
def selection_sort(arr):

    # Внешний цикл, проходящий по всем элементам списка  
    for i in range(len(arr)):
        # Предположение, что текущий индекс i является 
        # индексом минимального элемента  
        min_index = i
        
        # Внутренний цикл, проходящий по оставшимся элементам списка
        for j in range(i+1, len(arr)):  
            # Проверка, является ли текущий элемент меньшим, 
            # чем минимальный найденный
            if arr[j] < arr[min_index]:
                # Обновление индекса минимального элемента  
                min_index = j  

        # Обмен текущего элемента с найденным минимальным элементом                
        arr[i], arr[min_index] = arr[min_index], arr[i]
    # Возврат отсортированного списка arr 
    return arr

# Вызов функции с заданным списком и вывод результата
print(selection_sort([64, 25, 12, 22, 11]))
# Результат = [11, 12, 22, 25, 64]
```

3. [Сортировка вставками (Insertion Sort)](insertion_sort.py):
```insertion_sort.py
# Определение функции insertion_sort, принимающей список arr
def insertion_sort(arr):
    # Внешний цикл, проходящий по всем элементам списка
    for i in range(1, len(arr)):
        # Сохранение текущего элемента в переменной key
        key = arr[i]
        # Инициализация переменной j, указывающей на индекс предыдущего элемента
        j = i - 1

        # Внутренний цикл, проходящий по оставшимся элементам списка
        while j >= 0 and arr[j] > key:
            # Перемещение элемента вправо, если он больше текущего
            arr[j + 1] = arr[j]
            # Уменьшение j для проверки следующего элемента
            j -= 1

        # Вставка текущего элемента key на правильную позицию
        arr[j + 1] = key

    return arr  # Возврат отсортированного списка


# Вызов функции с заданным списком и вывод результата
print(insertion_sort([64, 25, 12, 22, 11]))
# Результат = [11, 12, 22, 25, 64]
```

4.[Быстрая сортировка (Quick Sort)](quick_sort.py):
```quick_sort.py
# Определение функции quick_sort, которая принимает список s
def quick_sort(s):  
    # Проверка, если длина списка меньше или равна 1
    if len(s) <= 1:  
       return s # Возврат списка, так как он уже отсортирован
        
    # Выбор первого элемента списка в качестве опорного
    element = s[0]

    # Создание списка left с элементами, меньшими опорного
    left = list(filter(lambda i: i < element, s))
    
    # Создание списка center с элементами, равными опорному  
    center = [i for i in s if i == element]  
    
    # Создание списка right с элементами, большими опорного
    right = list(filter(lambda i: i > element, s))  

    # Рекурсивный вызов quick_sort для списков left и right, 
    # объединение результатов
    return quick_sort(left) + center + quick_sort(right)  

# Вызов функции quick_sort с заданным списком и вывод результата
print(quick_sort([5, 2, 9, 0, 1, 5, 3]))  
# Результат = [0, 1, 2, 3, 5, 5, 9]
```

5. [Сортировка слиянием (Merge Sort)](merge_sort.py):
```merge_sort.py
# Определение функции merge_sort, принимающей список arr
def merge_sort(arr):
    # Проверка, если длина списка меньше или равна 1
    if len(arr) <= 1:
        return arr  # Возврат списка, так как он уже отсортирован

    # Разделение списка на две половины
    mid = len(arr) // 2
    # Рекурсивный вызов merge_sort для левой половины
    left_half = merge_sort(arr[:mid])
    # Рекурсивный вызов merge_sort для правой половины
    right_half = merge_sort(arr[mid:])

    # Возврат объединеных отсортированных половин
    return merge(left_half, right_half)


# Определение функции merge, принимающей два отсортированных списка
def merge(left, right):
    # Инициализация пустого списка для объединения
    merged = []
    # Инициализация индексов для обеих половин
    left_index, right_index = 0, 0

    # Цикл, пока есть элементы в обеих половинах
    while left_index < len(left) and right_index < len(right):
        # Сравнение текущих элементов обеих половин
        if left[left_index] < right[right_index]:
            # Добавление меньшего элемента в объединенный список
            merged.append(left[left_index])
            # Увеличение индекса левой половины
            left_index += 1
        else:  # Если элемент правой половины меньше или равен
            # Добавление меньшего элемента в объединенный список
            merged.append(right[right_index])
            # Увеличение индекса правой половины
            right_index += 1
    # Добавление оставшихся элементов из левой половины, если они есть
    merged.extend(left[left_index:])
    # Добавление оставшихся элементов из правой половины, если они есть
    merged.extend(right[right_index:])

    return merged  # Возврат объединенного отсортированного списка

# Вызов функции с заданным списком и вывод результата
print(merge_sort([64, 25, 12, 22, 11]))
#  Результат = [11, 12, 22, 25, 64]
```