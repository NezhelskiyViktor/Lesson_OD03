# Определение функции merge_sort, принимающей список arr
def merge_sort(arr):
    # Проверка, если длина списка меньше или равна 1
    if len(arr) <= 1:
        return arr  # Возврат списка, так как он уже отсортирован

    # Разделение списка на две половины
    mid = len(arr) // 2
    # Рекурсивный вызов merge_sort для левой половины
    left_half = merge_sort(arr[:mid])
    # Рекурсивный вызов merge_sort для правой половины
    right_half = merge_sort(arr[mid:])

    # Возврат объединеных отсортированных половин
    return merge(left_half, right_half)


# Определение функции merge, принимающей два отсортированных списка
def merge(left, right):
    # Инициализация пустого списка для объединения
    merged = []
    # Инициализация индексов для обеих половин
    left_index, right_index = 0, 0

    # Цикл, пока есть элементы в обеих половинах
    while left_index < len(left) and right_index < len(right):
        # Сравнение текущих элементов обеих половин
        if left[left_index] < right[right_index]:
            # Добавление меньшего элемента в объединенный список
            merged.append(left[left_index])
            # Увеличение индекса левой половины
            left_index += 1
        else:  # Если элемент правой половины меньше или равен
            # Добавление меньшего элемента в объединенный список
            merged.append(right[right_index])
            # Увеличение индекса правой половины
            right_index += 1
    # Добавление оставшихся элементов из левой половины, если они есть
    merged.extend(left[left_index:])
    # Добавление оставшихся элементов из правой половины, если они есть
    merged.extend(right[right_index:])

    return merged  # Возврат объединенного отсортированного списка


# Вызов функции с заданным списком и вывод результата
print(merge_sort([64, 25, 12, 22, 11]))
